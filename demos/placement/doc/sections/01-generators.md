# Placement with Argo CD ApplicationSet Generators

When using `ApplicationSet` manifests with [Argo CD](https://argo-cd.readthedocs.io/en/stable/), you can use templates to create different `ApplicationSets` based on parameters generated by the ["Generator" section](https://argo-cd.readthedocs.io/en/stable/operator-manual/applicationset/Generators/). This can be useful for customizing the destination cluster and associated variables of the deployed application from a single `ApplicationSet` object.

There are multiple different Generators, but for convenience and simplicity, in this demo we are going to use:

* Creating an `Application` object per cluster configured in a static list in the `ApplicationSet`.
* In each of those clusters, creating an `Application` object per application located in a specific directory in a Git repository.

For the first point, we will be using the [Git generator](https://argo-cd.readthedocs.io/en/stable/operator-manual/applicationset/Generators-Git/), and for the second one, the [List generator](https://argo-cd.readthedocs.io/en/stable/operator-manual/applicationset/Generators-List/).

> **NOTE**
>
> You can also use other generators to achieve the same outcome, but these were selected for convenience and ease of use in this demo.

Since we are using multiple generators in the same `ApplicationSet` manifest, we must also use another type of "Generator," the [Matrix generator](https://argo-cd.readthedocs.io/en/stable/operator-manual/applicationset/Generators-Matrix/), to make them work together.

Below is a diagram illustrating the explained process:


```
                                                                  --> Child Application (Cluster 1 - dir 1)
                                                                 /
                                             --> (Git generator) -->  Child Application (Cluster 2 - dir 2)
                                           /                     \
                                          |                       --> Child Application (Cluster 1 - dir N)
                                          | 
                                          | 
                                          |                      --> Child Application (Cluster 1 - dir 1)
                                          |                     /                             
Parent ApplicationSet ---(List generator) ----> (Git generator) -->  Child Application (Cluster 2 - dir 2)
                                          |                     \
                                          |                      --> Child Application (Cluster 3 - dir N)
                                          | 
                                          |                         
                                          |                       --> Child Application (Cluster 1 - dir 1)
                                           \                     /
                                             --> (Git generator) -->  Child Application (Cluster 2 - dir 2)
                                                                 \
                                                                  --> Child Application (Cluster 1 - dir N)
```


Thanks to the "Matrix Generator" and templating, we can create all the different `Application` objects from a single manifest instead of having to create an `Application` object per cluster and per app, which simplifies management.

## Deploy on Cloud

To deploy the child applications, create the parent `ApplicationSet` object with the Generators:

1. Access your OpenShift console in the Hub cluster.
2. Click the `+` button to add resources.
3. Paste the following content, changing the `repoURL` to point to your own repo:

    ```yaml
    apiVersion: argoproj.io/v1alpha1
    kind: ApplicationSet
    metadata:
      labels:
        app.kubernetes.io/managed-by: demo-placement-global
      name: demo-placement-global
      namespace: openshift-gitops
    spec:
      generators:
        - matrix:
            generators:
              - git:
                  directories:
                    - path: demos/placement/apps/welcome/*
                  repoURL: 'https://github.com/luisarizmendi/openshift-edge-demos.git'
                  revision: main
              - list:
                  elements:
                    - cluster: local-cluster
                      url: https://kubernetes.default.svc
      goTemplate: true
      goTemplateOptions:
        - missingkey=error
      template:
        metadata:
          labels:
            app.kubernetes.io/managed-by: demo-placement-global
          name: '{{.path.basename}}-{{.cluster}}'
        spec:
          destination:
            namespace: '{{.path.basename}}'
            server: '{{.url}}'
          project: demo-placement
          source:
            helm:
              valueFiles:
                - values.yaml
                - environment/values-{{.cluster}}.yaml
              path: '{{.path.path}}'
              repoURL: 'https://github.com/luisarizmendi/openshift-edge-demos.git'
              targetRevision: main
          syncPolicy:
            automated:
              prune: true
              selfHeal: true
    ```

In this parent `ApplicationSet` object, you can see both the "Git Generator" and the "List Generator." The "List Generator" includes information about the target clusters where the apps will be deployed, while the "Git Generator" points to the directory located in the Git repository where the different manifests of each app (separated into dedicated subdirectories) reside.

## Deploy on Edge

Now we are going to switch the app from the Cloud to the Edge clusters. To do that, follow these steps:

1. Access your OpenShift console in the Hub cluster.
2. Edit the `demo-placement-global` object. You can find it by clicking on "Explore API" and looking for `ApplicationSet` `argoproj.io/v1alpha1` instances.
3. Modify the "List generator" with the information of the Edge clusters:

    ```yaml
    ...
    ...
    generators:
        - matrix:
            generators:
              - git:
                  directories:
                    - path: demos/placement/apps/welcome/*
                  repoURL: 'https://github.com/luisarizmendi/openshift-edge-demos.git'
                  revision: main
              - list:
                  elements:
                    - cluster: edge-1
                      url: https://<cluster 1 mgmt url>:6443
                    - cluster: edge-2
                      url: https://<cluster 2 mgmt url>:6443
    goTemplate: true
    goTemplateOptions:
        - missingkey=error
    template:
    ...
    ...
    ```

You will see how the "hello" app deployed in the `local-cluster` starts being deleted and, at the same time, is deployed in the specified clusters in the `values` file.

## Clean-Up

Once you have finished moving the app around your clusters, you can delete the `Application` and `ApplicationSet` objects:

1. Access your OpenShift console in the Hub cluster.
2. Click the `+` button to add resources.
3. Paste the following content:

    ```yaml
    apiVersion: batch/v1
    kind: Job
    metadata:
      generateName: cleanup-demo-placement-global-
      namespace: openshift-gitops
    spec:
      template:
        spec:
          serviceAccountName: openshift-gitops-argocd-application-controller
          containers:
            - name: delete-apps
              image: openshift/origin-cli:latest
              command: ["oc"]
              args: ["delete", "applications", "-n", "openshift-gitops", "-l", "app.kubernetes.io/managed-by=demo-placement-global"]
            - name: delete-appsets
              image: openshift/origin-cli:latest
              command: ["oc"]
              args: ["delete", "applicationsets", "-n", "openshift-gitops", "-l", "app.kubernetes.io/managed-by=demo-placement-global"]
          restartPolicy: Never
    ```

## Going Beyond

In this example, we are making changes directly on the object in OpenShift, but you can also align more with the GitOps paradigm by placing the `ApplicationSet` descriptor in Git and creating it from an additional `Application` object. This way, you can make changes in the Git file instead of directly in the object for better traceability.

You could also use different generators to deliver apps in different clusters with their associated specific values.
